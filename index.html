<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lampaka Jump</title>
<style>
  html, body {
    margin: 0; padding: 0;
    background: #87CEFA;
    overflow: hidden;
    touch-action: manipulation;
    user-select: none;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: #87CEFA;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let width, height;
function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

const groundHeight = 100;
const lampakaSize = 80;

let lampaka = {
  x: width * 0.15,
  y: height - groundHeight - lampakaSize,
  vy: 0,
  jumping: false
};

const gravity = 2.0;
const jumpStrength = -40;
let speed = 4;
let score = 0;
let highscore = localStorage.getItem('highscore') || 0;
let gameOver = false;

let boxes = [];
const minGap = 600;  // größerer Abstand für mehr Platz
const maxGap = 900;

const lampakaImg = new Image();
lampakaImg.src = "Lampaka.png"; // Pfad zu deinem Bild

// Spawnt neue Kakteen mit garantiertem Mindestabstand
function spawnBox() {
  let lastX = boxes.length > 0 ? boxes[boxes.length - 1].x : width + 200;
  let gap = Math.random() * (maxGap - minGap) + minGap;
  boxes.push({ x: lastX + gap, y: height - groundHeight });
}

// Initiale Kakteen erzeugen, mit Abstand zueinander
function initBoxes() {
  boxes = [];
  let currentX = width + 200;
  for (let i = 0; i < 5; i++) {
    boxes.push({ x: currentX, y: height - groundHeight });
    currentX += Math.random() * (maxGap - minGap) + minGap;
  }
}
initBoxes();

function drawCactus(x, y, size) {
  ctx.fillStyle = '#228B22';
  const w = size * 0.5;
  const h = size;
  ctx.fillRect(x, y - h, w, h);
  ctx.fillRect(x - w * 0.5, y - h * 0.7, w * 0.5, h * 0.3);
  ctx.fillRect(x + w, y - h * 0.7, w * 0.5, h * 0.3);
}

function jump() {
  if (!lampaka.jumping && !gameOver) {
    lampaka.vy = jumpStrength;
    lampaka.jumping = true;
  }
}
window.addEventListener('touchstart', e => { e.preventDefault(); jump(); }, { passive: false });
window.addEventListener('mousedown', jump);

function update() {
  if (gameOver) return;

  lampaka.vy += gravity;
  lampaka.y += lampaka.vy;

  if (lampaka.y > height - groundHeight - lampakaSize) {
    lampaka.y = height - groundHeight - lampakaSize;
    lampaka.vy = 0;
    lampaka.jumping = false;
  }

  for (let box of boxes) {
    box.x -= speed;
  }

  // Entferne Kakteen die raus sind
  while (boxes.length > 0 && boxes[0].x + lampakaSize * 0.5 < 0) {
    boxes.shift();
    // Neue Kaktus an sicherem Abstand spawn
    let lastX = boxes.length > 0 ? boxes[boxes.length - 1].x : width + 200;
    let gap = Math.random() * (maxGap - minGap) + minGap;
    boxes.push({ x: lastX + gap, y: height - groundHeight });
    score++;
    if (score > highscore) {
      highscore = score;
      localStorage.setItem('highscore', highscore);
    }
    if (score % 5 === 0) speed += 0.5;
  }

  // Kollisionserkennung
  for (let box of boxes) {
    const cactusW = lampakaSize * 0.5;
    const cactusH = lampakaSize;
    if (
      lampaka.x < box.x + cactusW &&
      lampaka.x + lampakaSize > box.x &&
      lampaka.y + lampakaSize > box.y - cactusH
    ) {
      gameOver = true;
      setTimeout(resetGame, 1500);
    }
  }
}

function resetGame() {
  score = 0;
  speed = 4;
  lampaka.y = height - groundHeight - lampakaSize;
  lampaka.vy = 0;
  lampaka.jumping = false;
  gameOver = false;
  initBoxes();
}

function draw() {
  ctx.clearRect(0, 0, width, height);

  // Himmel
  ctx.fillStyle = '#87CEFA';
  ctx.fillRect(0, 0, width, height);

  // Boden
  ctx.fillStyle = '#228B22';
  ctx.fillRect(0, height - groundHeight, width, groundHeight);

  // Lampaka
  if (lampakaImg.complete && lampakaImg.naturalWidth !== 0) {
    ctx.drawImage(lampakaImg, lampaka.x, lampaka.y, lampakaSize, lampakaSize);
  } else {
    ctx.fillStyle = 'red';
    ctx.fillRect(lampaka.x, lampaka.y, lampakaSize, lampakaSize);
  }

  // Kakteen
  for (let box of boxes) {
    drawCactus(box.x, box.y, lampakaSize);
  }

  // Score
  ctx.fillStyle = 'white';
  ctx.font = '30px monospace';
  ctx.fillText(`Punkte: ${score}`, 20, 50);
  ctx.fillText(`Highscore: ${highscore}`, 20, 90);

  // Game Over Overlay
  if (gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = 'white';
    ctx.font = '80px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', width / 2, height / 2);
    ctx.textAlign = 'start';
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

</script>

</body>
</html>
